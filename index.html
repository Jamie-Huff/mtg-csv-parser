<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manabox to Crystal Commerce CSV Parser</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="header-bar">
        <h1>MTG North Card Scanner</h1>
    </div>

    <nav class="nav-bar">
        <ul>
            <li><button class="nav-link" onclick="openAboutModal()">About</button></li>
        </ul>
    </nav>

    <div class="main-content">
        <div class="container">
            <div class="upload-area" id="uploadArea">
                <p>Click to upload your CSV file or drag and drop it here</p>
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                    Choose CSV File
                </button>
                <input type="file" id="fileInput" accept=".csv" />
            </div>

            <div id="status" class="status"></div>
        </div>
    </div>

    <div id="aboutModal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeAboutModal()">&times;</span>
            <div class="modal-body">
                <h1>MTG North Card Scanner</h1>

                <h2>Goal</h2>
                <p>The goal of this script is to take a CSV file output by an MTG card scanning application, specifically <strong>Manabox</strong>, feed it into this script, and get a new CSV output that can be used to update your inventory for an ecommerce platform, in this case <strong>Crystal Commerce</strong>.</p>

                <h2>Using Manabox</h2>
                <p>Making sure you select the correct printing of the card.</p>

                <h2>Potential Issues</h2>
                <ul>
                    <li><strong>Set Name Formatting</strong>: Manabox exports the "set name" to be formatted exactly the same as Scryfall. If your "category" on Crystal Commerce is not formatted the same way it could run into an issue.</li>
                    <li><strong>Missing Cards</strong>: Need to test to see what happens if the card doesn't exist in Manabox.</li>
                    <li><strong>Performance</strong>: This isn't optimized at all, might have to revisit the time complexity of the script to let it handle bigger input files if that becomes an issue.</li>
                    <li><strong>Inventory Updates</strong>: The export field needs to be "Add Qty" to ensure that Crystal Commerce adds it to the inventory and doesn't just override the existing quantity.</li>
                </ul>

                <h2>Usage</h2>
                <ol>
                    <li>Scan cards on Manabox</li>
                    <li>Move the scanned cards over to a binder once complete</li>
                    <li>Click the three dots in the top corner of the binder to export to a CSV file</li>
                    <li>Somehow send it to your computer (maybe this works on mobile idk), probably just email it to yourself</li>
                    <li>Open up the HTML page in your local browser by double clicking on the document or through the hosting on GitHub Pages, drag in/upload your Manabox CSV file</li>
                    <li>The page will automatically download the exported CSV</li>
                    <li>Head to your Crystal Commerce inventory, click on mass import, select "includes multiple categories"</li>
                </ol>

                <h2>Customization</h2>
                <p>Customize the <code>convertToExportFormat</code> function's output with your desired import and export fields. Structured like:</p>
                <pre><code>{
    {export heading name}: row[{import heading name}]
}</code></pre>
            </div>
        </div>
    </div>

    <script>
        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.getElementById('uploadArea');
        const statusDiv = document.getElementById('status');

        fileInput.addEventListener('change', handleFile);

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');

            const files = e.dataTransfer.files;
            if (files.length > 0) {
                processFile(files[0]);
            }
        });

        function openAboutModal() {
            document.getElementById('aboutModal').style.display = 'block';
        }

        function closeAboutModal() {
            document.getElementById('aboutModal').style.display = 'none';
        }

        window.onclick = function(event) {
            const modal = document.getElementById('aboutModal');
            if (event.target === modal) {
                closeAboutModal();
            }
        }

        function handleFile() {
            const file = fileInput.files[0];
            if (file) {
                processFile(file);
            }
        }

        function showStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
        }

        function hideStatus() {
            statusDiv.style.display = 'none';
        }

        function getCurrentDate() {
            const now = new Date();
            const day = String(now.getDate()).padStart(2, '0');
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const year = now.getFullYear();
            return `${day}-${month}-${year}`;
        }

        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            const headers = lines[0].split(',');
            const rows = [];

            for (let lineNum = 1; lineNum < lines.length; lineNum++) {
                const values = [];
                let currentValue = '';
                let inQuotes = false;

                for (let lineField = 0; lineField < lines[lineNum].length; lineField++) {
                    const char = lines[lineNum][lineField];

                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        values.push(currentValue.trim());
                        currentValue = '';
                    } else {
                        currentValue += char;
                    }
                }
                values.push(currentValue.trim());

                if (values.length === headers.length) {
                    const row = {};
                    headers.forEach((header, index) => {
                        row[header.trim()] = values[index];
                    });
                    rows.push(row);
                }
            }

            return rows;
        }

        function convertToExportFormat(data) {
            const convertedData = [];

            for (let lineNumber = 0; lineNumber < data.length; lineNumber++) {
                const row = data[lineNumber];
                const importDocLineNumber = lineNumber + 2; // +2 because index starts at 0 and we skip header row

                // this is pretty jank I should probably make it more modular later
                if (!row.hasOwnProperty('Name') || row['Name'].trim() === '') {
                    throw new Error(`Line ${importDocLineNumber}: Missing product name`);
                }

                if (!row.hasOwnProperty('Set name') || row['Set name'].trim() === '') {
                    throw new Error(`Line ${importDocLineNumber}: Missing set name`);
                }

                if (!row.hasOwnProperty('Quantity') || row['Quantity'].trim() === '') {
                    throw new Error(`Line ${importDocLineNumber}: Missing quantity`);
                }

                const quantity = parseInt(row['Quantity']);
                if (isNaN(quantity) || quantity <= 0) {
                    throw new Error(`Line ${importDocLineNumber}: Invalid quantity "${row['Quantity']}" (must be a positive number)`);
                }

                const output = {
                    'Product Name': row['Name'].trim(),
                    'Category': row['Set name'].trim(),
                    'Condition': 'Near Mint',
                    'Language': 'English',
                    'Add Qty': quantity
                };

                convertedData.push(output);
            }

            return convertedData;
        }

        function generateCSV(data) {
            const headers = ['Product Name', 'Category', 'Condition', 'Language', 'Add Qty'];
            const csvLines = [headers.join(',')];

            data.forEach(row => {
                const values = headers.map(header => {
                    const value = row[header];
                    if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
                        return `"${value.replace(/"/g, '""')}"`;
                    }
                    return value;
                });
                csvLines.push(values.join(','));
            });

            return csvLines.join('\n');
        }

        function downloadCSV(csvContent, filename) {
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');

            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        function processFile(file) {
            if (!file.name.toLowerCase().endsWith('.csv')) {
                showStatus('Please select a CSV file', 'error');
                return;
            }

            showStatus('Processing file...', 'processing');

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvText = e.target.result;
                    const parsedData = parseCSV(csvText);

                    if (parsedData.length === 0) {
                        throw new Error('No data found in the CSV file');
                    }

                    const exportData = convertToExportFormat(parsedData);
                    const outputCSV = generateCSV(exportData);

                    const currentDate = getCurrentDate();
                    const filename = `export-${currentDate}.csv`;

                    downloadCSV(outputCSV, filename);

                    showStatus(`âœ… Successfully processed ${exportData.length} cards and downloaded ${filename}`, 'success');

                } catch (error) {
                    showStatus(`Error: ${error.message}`, 'error');
                }
            };

            reader.onerror = function() {
                showStatus('Error reading file', 'error');
            };

            reader.readAsText(file);
        }
    </script>
</body>
</html>
